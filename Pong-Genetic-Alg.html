<!DOCTYPE html>

<h1 id="loading">Loading</h1>
<canvas id="canvas"></canvas>
<style>
  canvas {
    padding-left: 0;
    padding-right: 0;
    margin-left: auto;
    margin-right: auto;
    display: block;
    width: 740;
  }
</style>
<script>

document.body.style.backgroundColor = "black";

var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

ctx.canvas.width = 910;
ctx.canvas.height = 480;

//player variables
function Player(player) {
	this.x = player.x;
	this.y = player.y;
	this.width = player.width;
	this.height = player.height;
	this.velX = player.velX;
	this.velY = player.velY;
	this.facing = player.facing;
	this.gun = player.gun;
	this.roomX = player.roomX;
	this.roomY = player.roomY;
	this.jumpPower = player.jumpPower;
	this.jumped = false;
	this.doubleJumped = false;
	this.state = "standing";
	this.speed = player.speed;
	this.canShoot = true;
	this.canSwitchWeapons = true;
	this.color = player.color;
	this.offsetX = player.offsetX;
	this.offsetY = player.offsetY;
	this.class = player.class;
}

var player1 = new Player({
	x: ctx.canvas.width / 2 - 25,
	y: ctx.canvas.height / 2 + 50,
	width: 25,
	height: 50,
	velX: 0,
	velY: 0,
	facing: "right",
	gun: "pistol",
	roomX: 0,
	roomY: 0,
	jumpPower: 12,
	speed: 8,
	color: "red",
	offsetX: -170,
	offsetY: -9000,
	class: "soldier"
});

var numOfPlatforms = 2;
var platformsAdded = 0;

//Number of images loaded, for later
var imagesLoaded = 0;
var maxImages = 0;

var debugging = true;

//World values
//Lower friction value = more friction. It's confusing
var friction = 0.8;
//Lower gravity is self explanatory
var gravity = 0.85;

//https://gamedev.stackexchange.com/questions/49251/javascript-create-a-new-bullet-instance-every-time-a-user-event-is-triggered
var bullets = [];
var platforms = [];

var keys = [];

var map = "map1";

var map1 = [{
		name: "skyscraper",
		background: "#0064ab",
		width: 10000,
		height: 10000
	},
	{
		wallX: 800,
		wallY: 9915,
		wallWidth: 200,
		wallHeight: 90,
		color: "green",
		durability: 5
	},
	{
		wallX: 1000,
		wallY: 9810,
		wallWidth: 50,
		wallHeight: 150,
		color: "red",
		durability: 5
	}
];

function drawStandingPlayer(player) {
	if (player.class == "soldier") {
		ctx.fillStyle = player.color;
		ctx.fillRect(
			player.x - player.offsetX,
			player.y - player.offsetY,
			player.width,
			player.height
		);

	}
}

function drawCrouchingPlayer(player) {
	if (player.class == "soldier") {
		ctx.fillStyle = player.color;
		ctx.fillRect(
			player.x - player.offsetX,
			player.y - player.offsetY,
			player.width,
			player.height / 2
		);

	}
}



function Guard(x, y, color) {
	var guardVelY = 0;
	var guardJumped = false;
	var guardJumping = false;
	var direction = 0;
	this.x = x;
	this.y = y;
	this.color = color;
	var jumps = 0;

	//lvl = level, like the level the player is on. Pretty much so the guard doesn't just move through stuff
	this.gravity = function(lvl) {
		//If the guard isn't being stopped by any platforms, fall
		if (this.y > ctx.canvas.height - 50) {
			this.y = ctx.canvas.height - 50;
			guardVelY = 0;
			guardJumped = false;
		} else if (guardVelY <= 35.6) {
			this.y += guardVelY;
			guardVelY += gravity;
		}
	};

	this.moveRight = function(maxRight) {
		if (this.x < maxRight) {
			this.x += 5;
			ctx.fillStyle = this.color;
			ctx.fillRect(this.x, this.y, 25, 50);
		}
	};

	this.moveLeft = function(maxLeft) {
		if (this.x > maxLeft) {
			this.x -= 5;
			ctx.fillStyle = this.color;
			ctx.fillRect(this.x, this.y, 25, 50);
		}
	};

	this.jump = function(numOfJumps) {
		var maxJumps = numOfJumps;

		for (var i = 0; i < maxJumps; i++) {
			if (guardJumped == false) {
				guardVelY = -player1.jumpPower * 2;
				guardJumped = true;
			}
		}
	};

	this.patrol = function() {
		if (direction == 0) {
			if (this.x <= ctx.canvas.width / 2) {
				this.moveRight(ctx.canvas.width / 2);
			} else {
				direction = 1;
			}
		} else if (direction == 1) {
			if (this.x > 0) {
				this.moveLeft(0);
			} else {
				direction = 0;
			}
		}
	};

	this.regularGuard = function() {
		//I SUMMON GRAVIITYYYYY
		this.gravity();
		//Move left and right

		this.patrol();
		ctx.fillStyle = this.color;
		ctx.fillRect(this.x, this.y, 25, 50);
	};
}

var coolGuard = new Guard(50, ctx.canvas.height - 50, "green");

//Still tryna figure out bullets
//Using jkface's method

function Bullet(bullet, player) {
	//Gonna uese an object prototype
	this.active = true;
	this.color = "white";
	this.xVel = bullet.vel;
	this.yVel = bullet.vel;
	this.width = bullet.width;
	this.height = bullet.height;
	this.x = bullet.x;
	this.y = bullet.y;
	this.angle = bullet.angle;
	this.direction = player.facing;
	this.power = bullet.power;
	this.damage = bullet.damage;
}

Bullet.prototype.update = function() {
	if (this.active == true) {
		if (map == "map1") {
			if (this.x + this.width >= map1[0].width) {
				this.active = false;
			} else if (this.x <= 0) {
				this.active = false;
			} else if (this.y + this.height >= map1[0].height) {
				this.active = false;
			} else if (this.y <= 0) {
				this.active = false;
			}

			for (var i = 1; i < map1.length; i++) {
				//Bullet-wall collision
				//Curently uses a rectangle-rectangle collision algorithm. In the future, should upgrade to Sepearting Axis Theorem

				var x = map1[i].wallX;
				var y = map1[i].wallY;
				var width = map1[i].wallWidth;
				var height = map1[i].wallHeight;

				if (this.x + this.width + this.xVel >= x && this.y + this.height >= y && this.y - this.yVel <= y + height && this.x - this.xVel <= x + width) {
					this.active = false;
				}

			}
		}

		if (this.direction == "right") {
			this.x += this.xVel * Math.cos((this.angle * Math.PI) / 180);
			this.y += this.yVel * Math.sin((this.angle * Math.PI) / 180);
		} else if (this.direction == "left") {
			this.x -= this.xVel * Math.cos((this.angle * Math.PI) / 180);
			this.y -= this.yVel * Math.sin((this.angle * Math.PI) / 180);
		}
		// Store the current context state (i.e. rotation, translation etc..)
		ctx.save();

		//Convert degrees to radian
		var rad = (this.angle * Math.PI) / 180;

		//Set the origin to the center of the image
		ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

		//Rotate the canvas around the origin
		ctx.rotate(rad);

		//draw the image
		ctx.fillStyle = this.color;
		ctx.fillRect(
			(this.width / 2) * -1,
			(this.height / 2) * -1,
			this.width,
			this.height
		);

		// Restore canvas state as saved from above
		ctx.restore();

		//if(this.x >= ctx.canvas.width || this.x <= 0 || this.y >= ctx.canvas.height || this.y < 0){
		//	this.active = false;
		//}
	}
};

//Cryptographically secure random numbers, 'borrowed' from
//https://stackoverflow.com/questions/18230217/javascript-generate-a-random-number-within-a-range-using-crypto-getrandomvalues
function getRandomInt(min, max) {
	// Create byte array and fill with 1 random number
	var byteArray = new Uint8Array(1);
	window.crypto.getRandomValues(byteArray);

	var range = max - min + 1;
	var max_range = 256;
	if (byteArray[0] >= Math.floor(max_range / range) * range)
		return getRandomInt(min, max);
	return min + (byteArray[0] % range);
}

function drawGun(player) {
	if (player.gun == "pistol") {
		bullets.push(
			new Bullet({
					vel: 25,
					x: player.x - player.offsetX + player.width,
					y: player.y - player.offsetY+ player.height / 2,
					width: 12,
					height: 4,
					angle: getRandomInt(-6, 6),
					power: 3,
					damage: Math.floor(Math.random() * 33) + 26
				},
				player
			)
		);
	} else if (player.gun == "sniper") {
		bullets.push(
			new Bullet({
					vel: 100,
					x: player.x - player.offsetX + player.width,
					y: player.y - player.offsetY + player.height / 2,
					width: 25,
					height: 4,
					angle: Math.floor(Math.random() * (3 - -3)) - 3,
					power: 9,
					damage: Math.floor(Math.random() * 150) + 146
				},
				player
			)
		);
	} else if (player.gun == "machinegun") {
		bullets.push(
			new Bullet({
					vel: 25,
					x: player.x - player.offsetX + player.width,
					y: player.y - player.offsetY + player.height / 2,
					width: 10,
					height: 4,
					//Random angle up to 45 degrees
					angle: getRandomInt(-20, 20),
					power: 4,
					damage: getRandomInt(28, 35)
				},
				player
			)
		);
		bullets.push(
			new Bullet({
					vel: 25,
					x: player.x - player.offsetX + player.width,
					y: player.y - player.offsetY + player.height / 2,
					width: 10,
					height: 4,
					angle: getRandomInt(-20, 20),
					power: 4,
					damage: getRandomInt(28, 35)
				},
				player
			)
		);
	} else if (player.gun == "m4") {
		if (player.facing == "right") {
			bullets.push(
				new Bullet({
						vel: 35,
						x: player.x - player.offsetX + player.width,
						y: player.y - player.offsetY + player.height / 2,
						width: 15,
						height: 5,
						angle: getRandomInt(-8, 8),
						power: 5,
						damage: getRandomInt(49, 68)
					},
					player
				)
			);
		} else if (player.facing == "left") {
			bullets.push(
				new Bullet({
						vel: 35,
						x: player.x - player.offsetX,
						y: player.y - player.offsetY + player.height / 2,
						width: 15,
						height: 5,
						angle: getRandomInt(-8, 8),
						power: 5,
						damage: getRandomInt(49, 68)
					},
					player
				)
			);
		}
	}


	player.canShoot = false;
}

function randomNumber(maxNum, minNum) {
	return Math.floor(Math.random * maxNum) + minNum;
}

function frame() {
	window.scrollTo(0, 0);
	ctx.save();
	ctx.translate(player1.offsetX, player1.offsetY);

	//Stuff is done loading!
	document.getElementById("loading").innerHTML = "";
	//Clears the screen
	ctx.fillStyle = map1[0].background;
	ctx.fillRect(
		-player1.offsetX,
		-player1.offsetY,
		ctx.canvas.width,
		ctx.canvas.height
	);

	//Draw the map
	//0th index is used for settings of the map
	for (var i = 1; i < map1.length; i++) {

		var x = map1[i].wallX;
		var y = map1[i].wallY;
		var width = map1[i].wallWidth;
		var height = map1[i].wallHeight;


		ctx.fillStyle = map1[i].color;
		ctx.fillRect(x, y, width, height);

		//Collision

		//Top collision

    if(player1.state == "standing"){
      
		if (
			player1.y + Math.abs(player1.offsetY) + player1.height >= y &&
			player1.x + Math.abs(player1.offsetX) < x + width - player1.speed &&
			player1.x + Math.abs(player1.offsetX) + player1.width >
			x + player1.speed &&
			player1.y + Math.abs(player1.offsetY) + player1.height - player1.velY <=
			y + height / 2
		) {
			player1.velY = 0;
			player1.offsetY = -(y - player1.y - player1.height);
			player1.jumped = false;

			//Bottom wall
		} else if (
			player1.y + Math.abs(player1.offsetY) <= y + height &&
			player1.y + Math.abs(player1.offsetY) >= y + height / 2 &&
			player1.x + Math.abs(player1.offsetX) < x + width - player1.speed &&
			player1.x + Math.abs(player1.offsetX) + player1.width >
			x + player1.speed
		) {
			player1.velY = gravity;
			player1.offsetY = -(y - player1.y + height);
		}

		//Left wall collisio
		if (
			player1.x + Math.abs(player1.offsetX) + player1.width >= x &&
			player1.x + Math.abs(player1.offsetX) + player1.width <=
			x + width / 2 &&
			player1.y + Math.abs(player1.offsetY) + player1.height >
			y + player1.velY &&
			player1.y + Math.abs(player1.offsetY) < y + height
		) {
			player1.velX = 0;
			player1.offsetX = -(x - player1.x - player1.width);
			//Right wall collision
		} else if (
			player1.x + Math.abs(player1.offsetX) <= x + width &&
			player1.x + Math.abs(player1.offsetX) >= x + width / 5 &&
			player1.y + Math.abs(player1.offsetY) + player1.height >
			y + player1.velY &&
			player1.y + Math.abs(player1.offsetY) < y + height
		) {
			player1.velX = 0;
			player1.offsetX = -(x + width - player1.x);
		}
    } else if(player1.state == "crouching"){
      if (
			player1.y + Math.abs(player1.offsetY) + player1.height/2 >= y &&
			player1.x + Math.abs(player1.offsetX) < x + width - player1.speed &&
			player1.x + Math.abs(player1.offsetX) + player1.width >
			x + player1.speed &&
			player1.y + Math.abs(player1.offsetY) + player1.height/2 - player1.velY <=
			y + height / 2
		) {
			player1.velY = 0;
			player1.offsetY = -(y - player1.y - player1.height/2);
			player1.jumped = false;

			//Bottom wall
		} else if (
			player1.y + Math.abs(player1.offsetY) <= y + height &&
			player1.y + Math.abs(player1.offsetY) >= y + height / 2 &&
			player1.x + Math.abs(player1.offsetX) < x + width - player1.speed &&
			player1.x + Math.abs(player1.offsetX) + player1.width >
			x + player1.speed
		) {
			player1.velY = gravity;
			player1.offsetY = -(y - player1.y + height);
		}

		//Left wall collisio
		if (
			player1.x + Math.abs(player1.offsetX) + player1.width >= x &&
			player1.x + Math.abs(player1.offsetX) + player1.width <=
			x + width / 2 &&
			player1.y + Math.abs(player1.offsetY) + player1.height/2 >
			y + player1.velY &&
			player1.y + Math.abs(player1.offsetY) < y + height
		) {
			player1.velX = 0;
			player1.offsetX = -(x - player1.x - player1.width);
			//Right wall collision
		} else if (
			player1.x + Math.abs(player1.offsetX) <= x + width &&
			player1.x + Math.abs(player1.offsetX) >= x + width / 5 &&
			player1.y + Math.abs(player1.offsetY) + player1.height/2 >
			y + player1.velY &&
			player1.y + Math.abs(player1.offsetY) < y + height
		) {
			player1.velX = 0;
			player1.offsetX = -(x + width - player1.x);
		}
    }


	}

	//Updates all bullets
	bullets.forEach(function(theBullet) {
		theBullet.update();
	});
	//Draws the player
	if (player1.state == "standing") {
		drawStandingPlayer(player1);
	} else if (player1.state == "crouching") {
		drawCrouchingPlayer(player1);
	}

	ctx.restore();

	//Gotta rewrite collision code :(
	if (
		player1.y - player1.offsetY + player1.height + player1.velY >=
		map1[0].height
	) {
		player1.velY = 0;
		player1.jumped = false;
	}

	if (player1.y - player1.offsetY + player1.height >= map1[0].height) {
		player1.jumped = false;
	}

	//Debugging info
	if (debugging == true) {
		ctx.fillStyle = "black";
		ctx.font = "30px Arial";
		ctx.fillText("offsetX: " + Math.round(player1.offsetX), 10, 30);
		ctx.fillText("offsetY: " + Math.round(player1.offsetY), 10, 60);
		ctx.fillText("player1X: " + player1.x, 10, 90);
		ctx.fillText("player1Y: " + player1.y, 10, 120);
	}

	//Key detection stuff
	document.body.addEventListener("keydown", function(e) {
		keys[e.keyCode] = true;
	});

	document.body.addEventListener("keyup", function(e) {
		keys[e.keyCode] = false;
	});

	//Player 1
	if (keys[39]) {
		player1.facing = "right";
		if (player1.velX < player1.speed) {
			player1.velX += player1.speed / 4;
		}
	}

	if (player1.offsetX < 0) {
		if (keys[37]) {
			player1.facing = "left";
			if (player1.velX > -player1.speed) {
				player1.velX -= player1.speed / 4;
			}
		}
	} else {
		player1.offsetX = 0;
	}

	if (keys[38]) {
		if (player1.jumped == false) {
			player1.velY = -player1.jumpPower * 2;
			player1.jumped = true;
		}
	}

	//Crouch

	if (keys[40]) {
    	if(player1.state == "standing"){
        	player1.jumpPower = player1.jumpPower/2;
        	player1.offsetY -= player1.height/2;

			player1.state = "crouching";
        }
	} else {
    	if(player1.state == "crouching"){
        	player1.jumpPower = player1.jumpPower * 2;
        	player1.offsetY += player1.height/2;
			player1.state = "standing";
        }
	}

	if (keys[17]) {
		//Switch weapons
		if (player1.canSwitchWeapons) {
			if (player1.class == "soldier") {
				player1.canSwitchWeapons = false;
                //Can't shoot while switching weapons, duh
                player1.canShoot = false;
				if (player1.gun == "m4") {
					player1.gun = "machinegun";
				} else if (player1.gun == "machinegun") {
					player1.gun = "m4";
				}
			}
            
            setTimeout(function() {
				player1.canSwitchWeapons = true;
                player1.canShoot = true;
			}, 1000);
		} 
	}

	//Pew pew

	if (keys[90]) {
		if (player1.canShoot == true) {
			drawGun(player1);
			player1.canShoot = false;
			if (player1.gun == "machinegun") {
				setTimeout(function() {
					player1.canShoot = true;
				}, 60);
			} else if (player1.gun == "pistol") {
				setTimeout(function() {
					player1.canShoot = true;
				}, 350);
			} else if (player1.gun == "sniper") {
				setTimeout(function() {
					player1.canShoot = true;
				}, 1750);
			} else if (player1.gun == "m4") {
				setTimeout(function() {
					player1.canShoot = true;
				}, 100);
			}
		}
	}

	player1.offsetX -= player1.velX;
	player1.velX *= friction;

	//Terminal velocity
	if (player1.velY <= 36) {
		player1.offsetY -= player1.velY;
		player1.velY += gravity;
	}

	requestAnimationFrame(frame);
}

//If everything has loaded, then start the game
//It's commented out since for the pre-alpha version of the game I'm just using rectangles and circles lol.
//if(imagesLoaded == maxImages)

//When everything loads, start the animation loop
window.onload = frame();

</script>
