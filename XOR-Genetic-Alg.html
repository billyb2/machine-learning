<script>
//Stores all nn's
var neuralNetworks = [];
var outputs = [];
var costs = [];

var sumCost = 0;
var meanCost;

//Sigmoid function
//https://www.justgivemeanexample.com/example/create-a-sigmoid-function-in-javascript
function sigmoid(input) {
	return 1 / (1 + Math.exp(-input));
}

function init(numOfnns) {
	for (var i = 0; i < numOfnns; i++) {
		neuralNetworks.push({
			//2 inputs
			//4 weights
			weights1: [(Math.random() * 2) - 1, (Math.random() * 2) - 1, (Math.random() * 2) - 1, (Math.random() * 2) - 1],
			//2 biases
			biases: [(Math.random() * 20) - 10, (Math.random() * 20) - 10],
			//4 weights
			weights2: [(Math.random() * 2) - 1, (Math.random() * 2) - 1]

			//1 output
		});
	}
}

function calcOutput(input1, input2, index){
	//Calculates the input of the two hidden neurons
    //While this could be done all at once, I find it's easier to understand this way.
	var hn1 = sigmoid( (input1 * neuralNetworks[index].weights1[0]) + (input2 *  neuralNetworks[index].weights1[2]) + neuralNetworks[index].biases[0]);
    
    var hn2 = sigmoid( (input1 * neuralNetworks[index].weights1[1]) + (input2 *  neuralNetworks[index].weights1[3]) + neuralNetworks[index].biases[1]);
    
    var output = sigmoid( hn1 * neuralNetworks[index].weights2[0] + hn2 * neuralNetworks[index].weights2[1]);
    
    return output;
    
}

//Initializes the amount of neural networks requested by the user with random weights and biases
init(100);

//Calculate all the outputs for all the NN's and all possible inputs, and store it in the outputs array.
for(var i = 0; i < neuralNetworks.length; i++){
	outputs.push( [calcOutput(0, 0, i), calcOutput(0, 1, i), calcOutput(1, 1, i), calcOutput(1, 0, i)] );
}

//After that's done, calculate the cost using the mean squared error.
//Again, this could be done in one step, and should be for efficiency's sake, but to make it easier to understand I'm seperating the steps
for(var i = 0; i < outputs.length; i++){
	//Calculates the difference between the predicted and actual answer for XOR of 1 and 1 and squares it
    //Same for all of the others
    
	var xor00Difference = Math.pow(outputs[i][0] - 0, 2);
    var xor01Difference = Math.pow(outputs[i][1] - 1, 2);
    var xor11Difference = Math.pow(outputs[i][2] - 0, 2);
    var xor10Difference = Math.pow(outputs[i][3] - 1, 2);
    
    //Outputs the mean of the differences to the costs array
    costs.push( (xor00Difference + xor01Difference + xor11Difference + xor10Difference)/4 );
    
}

//Now there are multiple ways that we could find out which algorithms did the best, but since I'm not smart enough to do it another way, we're going to find the mean of all of the algorithms' costs, and which ever ones are lower than the mean get to survive

//First, we've gotta find the mean

//Find the sum of all of the costs
for(var i = 0; i < costs.length; i ++){
	sumCost += costs[i];
}


//And divide it by the number of costs
meanCost = (sumCost/costs.length);

//Now we check every individual agorithm's cost, and if the cost is higher than the average (which means it performed worse), it dies. 
//Gruesome ik
//Do this repeatedly, until the number of neural networks is below half of the original amount and there's an even number
//Again, this is a really lazy approach to doing this, but it should work for the time being

alert(costs.length);
var badIndexes = [];

/**While this is a pretty complex and computationally expensive method, 
it's a simple one to produce. If i just removed all of the bad indexes with array.splice(), it would always stop after removing 50.
**/
for(var i = 0; i < costs.length; i++){
	
    
	if (costs[i] > meanCost){
    	badIndexes.push(i);
    }
}

for(var i = 0; i < badIndexes.length; i ++){
	costs.splice(badIndexes[i], 1);
}

//Now for the actual reproduction/mutation part


</script>
